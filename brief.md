Обо мне
===

Cлайд: фото, контакты, место работы/учёбы.

О GetShop.TV
===

Чем мы занимаемся?
---

Слайд: логотип и слоган (?)

GetShop.TV – технология, позволяющая зрителям рекламы на Web и SmartTV
покупать товары и услуги, получать купоны на скидку и регистрироваться в
конкурсах, не вставая с дивана.

Успешных стартапов достаточно, но я про нас рассказываю не для того, чтобы
похвалиться, а потому что у нас весь бэкенд на Haskell.

А ещё мы планируем провести конференцию.

С кем и почему интегрируемся?
---

Слайд: наш сервер посередине и внешние сервисы вокруг.

Мы используем внешние сервисы для SIP телефонии (два разных сервиса -- для
перенаправления звонков по горячей линии и для более сложных сценариев связи
с колл-центом), для отправки SMS и с недавнего времени для распознавания
объектов в видео-потоке.

У всех этих сервисов совершенно разные принципы работы и сильно отличающаяся
по качеству и понятности документация. Поскольку наш сервер написан на
Haskell, нам нужны HTTP клиенты, написанные на Haskell. Некоторые сервисы
предоставляют готовые клиенты на JS/PHP/Java, они могут быть полезны
при разработке, но мы не хотим и не будем их использовать.

Собственноручно написанный клиент на Haskell позволит отсеять значительную
часть ошибок ещё на этапе компиляции, а в дальнейшем гарантировать, что
мы передаём данные в правильном формате.

Сервер на Haskell
===

Мы используем библиотеку `servant` для описания нашего API, сервера и клиента.
Её отличительной особенностью является то, что API описывается как тип
данных языка Haskell с использованием комбинаторов, которые предоставляет
библиотека (`Capture`, `QueryParam`...).

Слайд: <пример API>

На основе этого типа можно написать сервер: для этого достаточно описать
функции, которые принимают на вход параметры запроса как аргументы.

Слайд: <пример>

Клиент представляет собой структуру данных, состоящую из функций того же
типа, за исключением возвращаемого значения. Сопоставление с API тоже
происходит автоматически на уровне типов (это мы сделали!).

Слайд: <пример>

Большая часть данных передаётся в формате JSON. Для перевода произвольной
структуры в JSON используется библиотека `aeson`. Она тоже может всё сделать
автоматически.

Слайд: <пример>

Основные проблемы при написании клиента
===

Слайд: список, затем каждый пункт с примером.

- Несоответствие типов
- Опечатки в названиях
- Незадокументированные параметры
- Отсутствие/противоречивость примеров
- Нестандартный ответ (хуки или 200 Ok с телом, что произошла ошибка)

Строгая типизация Haskell очень помогает найти ошибки и быстро их исправить.
Уже на этапе компиляции можно обнаружить пропущенные параметры и аргументы
с неверным типом. Основная часть работы -- описание API и структур данных
(на самом деле -- поиск отличий документации от реальности).

Общие советы
===

Слайд: основная проблема -- кривая документация. Что делать?

Слайды на каждый пункт.
- Очень внимательно читать документацию, какой бы ужасной она не была.
  Попробовать переписать под себя в удобном виде (отсортировать endpointы,
  выделить сомнительные части)
- Проверить всё curlом -- станут понятны реальные типы данных
- Если есть готовые клиенты на других языках, можно посмотреть, какие типы
  данных используются в них (скорее всего их писали люди, более приближенные
  к технической стороне процесса, чем составители документации)
- Описать используемые типы данных -- лучше отдельно для запросов/ответов
- Если непонятно, что на самом деле приходит в ответ, везде использовать
  универсальное представление: текст или JSON
- Описать [часть] API
- Описать клиента для API.
- Тестировать по отдельности, пробовать все варианты, убирать параметры,
  добавлять лишние и т.д.
- Проработать реальные сценарии
- Примерная структура:

```
  Foo/
    API.hs
    Client.hs
    Types/
        Request.hs
        Response.hs
        Common.hs
```

- Можно написать разработчикам и посоветовать исправить документацию или
  спросить, как должно быть на самом деле

Чем наша документация лучше?
===

Слайд: д'Артаньян

Генерация swagger.json автоматически
---

Схема представляет собой файл в формате JSON, в котором указана версия
API, перечислены все endpointы с параметрами, телами запроса и ответа, а также
их формат. Для данных в формате JSON указаны типы полей, обязательны ли они.
Можно добавлять комментарии, примеры значений и ограничения на них,
разбивать API на логические части с помощью тегов.

Файл генерируется автоматически, но для этого каждый тип данных должен
иметь isntane ToSchema для тел запроса/ответа и ToParamSchema для параметров.
Если есть instance Generic, то можно это сделать автоматически, или сделать это
вручную, например, чтобы добавить комментарий или примеры возможных значений.

Слайд с примером для той же структуры, что и JSON.

Тестирование
---

- Проверка соответствия ToJSON и ToSchema

Иногда приходится вручную описывать схему для некоторых структур данных, и
никто не застрахован от ошибки.
Нужна всего одна строчка кода, чтобы проверить, что представление структур
данных в JSON соответствует сгенерированной swagger-схеме. Мы добавили это
в тесты, поэтому обязательно заметим несоответствие ещё в процессе разработки.

Слайд: <пример>

- Проверка соответствия сгенерированного файла и реального API

Также в тестах проверяется актуальность сгенерированного файла и реального API,
чтобы не забывать его обновлять. Поэтому наши партнёры никогда не увидят
устаревшую документацию.

swagger-ui и "живое" тестирование
---

Пакет `servant-swagger-ui` позволяет добавить к API "живую" документацию:
помимо описания параметров, интерфейс предоставляет возможность протестировать
API.

Живая демонстрация.

Заключение
===

Было рассмотрено:
- проблемы при написании HTTP клиентов для сторонних сервисов
- как удобнее построить процесс их разработки и тестирования
- кратко показаны возможности библиотек `servant`, `aeson`, `swagger2`

Ещё раз про нашу конференцию, спасибо за внимание, вопросы.
