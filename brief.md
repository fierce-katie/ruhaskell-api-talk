Обо мне
===

О GetShopTV
===

Чем мы занимаемся?
---

С кем и почему интегрируемся?
---

Мы используем внешние сервисы для SIP телефонии (два разных сервиса -- для
перенаправления звонков по горячей линии и для более сложных сценариев связи
с колл-центом), для отправки SMS и с недавнего времени для распознавания
объектов в видео-потоке.

У всех этих сервисов совершенно разные принципы работы и сильно отличающаяся
по качеству и понятности документация. Поскольку наш сервер написан на
Haskell, нам нужны HTTP клиенты, написанные на Haskell. Некоторые сервисы
предоставляют готовые клиенты на JS/PHP/Java, они могут быть полезны
при разработке, но мы не хотим и не будем их использовать.

Собственноручно написанный клиент на Haskell позволит отсеять значительную
часть ошибок ещё на этапе компиляции, а в дальнейшем гарантировать, что
мы передаём данные в правильном формате.

Библиотека `servant`
===

Мы используем библиотеку `servant` для описания нашего API, сервера и клиента.
Её отличительной особенностью является то, что API описывается как тип
данных языка Haskell с использованием комбинаторов, которые предоставляет
библиотека (`Capture`, `QueryParam`...).

<пример API>

На основе этого типа можно написать сервер: для этого достаточно описать
функции, которые принимают на вход параметры запроса как аргументы.

<пример>

Клиент представляет собой структуру данных, состоящую из функций того же
типа, за исключением возвращаемого значения. Сопоставление с API тоже
происходит автоматически на уровне типов (это мы сделали!).

<пример>

Основные проблемы при написании клиента
===

- Несоответствие типов
- Опечатки в названиях
- Незадокументированные параметры
- Отсутствие/противоречивость примеров
- Нестандартный ответ (хуки или 200 Ok с телом, что произошла ошибка)

Примеры для каждого пункта.
Строгая типизация Haskell очень помогает найти ошибки и быстро их исправить.
Уже на этапе компиляции можно обнаружить пропущенные параметры и аргументы
с неверным типом. Основная часть работы -- описание API и структур данных
(на самом деле -- поиск отличий документации от реальности).

Общие советы
===

- Очень внимательно читать документацию, какой бы ужасной она не была.
  Попробовать переписать под себя в удобном виде (отсортировать endpointы,
  выделить сомнительные части)
- Проверить всё curlом -- станут понятны реальные типы данных
- Если есть готовые клиенты на других языках, можно посмотреть, какие типы
  данных используются в них (скорее всего их писали люди, более приближенные
  к технической стороне процесса, чем составители документации)
- Описать используемые типы данных -- лучше отдельно для запросов/ответов
- Если непонятно, что на самом деле приходит в ответ, везде использовать
  универсальное представление: текст или JSON
- Описать [часть] API
- Описать клиента для API.
- Тестировать по отдельности, пробовать все варианты, убирать параметры,
  добавлять лишние и т.д.
- Проработать реальные сценарии
- Примерная структура:

```
  Foo/
    API.hs
    Client.hs
    Types/
        Request.hs
        Response.hs
        Common.hs
```

- Можно написать разработчикам и посоветовать исправить документацию или
  спросить, как должно быть на самом деле

Чем наша документация лучше?
===

Генерация swagger.json автоматически
---

Проверка соответствия ToJSON и ToSchema
---

Проверка соответствия сгенерированного файла и реального API
---

swagger-ui и "живое" тестирование
---

Заключение
===

